"use strict";

var Other = "other";
var WaitingForReview = "waiting for review";
var WaitingForAuthor = "waiting for author";
var WaitingForBots = "waiting for bots";
var NotWaiting = "not waiting";


var ChangedReviewers = "changed reviewers";
var CQBitChecked = "CQ bit checked";
var CQBitUnchecked = "CQ bit unchecked";
var Comments = "Review comments";
var ResponseToComments = "Response to comments";
var Committed = "Committed";
var AutoGenerated = "automatic message";
var NewPatchset = "new patchset"
var BotAction = "automatic action"

var fastAnnotateGerrit = (function() {


function fastAnnotate(data) {
  createDateDeltas(data);
  classifyMessageTypes(data);
  generateEffectiveReviewers(data);
  classifyWaitingType(data);
  computeAggregateWaitingTimes(data);
  addCodereviewStyleInfo(data);
  data.source = 'gerrit';
  return data;
}

function createDateDeltas(data) {
  var d = Date.parse(data.created);

  // process dates into deltas
  for (var message of data.messages) {
    var e = Date.parse(message.date);
    message.delta = e - d;
    d = e;
  }
}

var gerritMessagePragmas = {
  "Commit-Queue+1": CQBitChecked,
  "Commit-Queue+2": CQBitChecked,
  "-Commit-Queue": CQBitUnchecked
}

// TODO: Determine other message tag types
var gerritMessageTags = {
  "autogenerated:gerrit:newPatchSet": NewPatchset,
  "autogenerated:cq:merged": Committed,
  "autogenerated:cq:dry-run": BotAction,
  "autogenerated:gerrit:setWorkInProgress": BotAction
}

function classifyMessageTypes(data, isGerrit) {
  for (var message of data.messages) {
    if (message.tag) {
      message.type = gerritMessageTags[message.tag];
      message.auto_generated = true;
    } else {
      // It isn't easy to tell whether Gerrit messages are
      // "autogenerated" (or process-generated) or not. Some
      // have the autogenerated tag applied but others are
      // exposed just as normal comments from the author.
      for (var pragma in gerritMessagePragmas) {
        if (message.message.includes(pragma)) {
          message.type = gerritMessagePragmas[pragma];
          message.auto_generated = true;
        }
      }

      if (!message.type) {
        if (message.message.includes("Patch Set") && message.sender == data.owner_email) {
          message.type = ResponseToComments;
        } else {
          message.type = Comments;
        }
      }
    }
  }
}

function generateEffectiveReviewers(data) {
  // set effective reviewers
  var lgtm = [];

  var reviewers = data.reviewers || [];
  var reviewerUpdates = data.reviewer_updates;
  var needsSyntheticMessage = false;

  var currentUpdate = reviewerUpdates[0];
  reviewerUpdates = reviewerUpdates.slice(1);

  var mergedMessages = [];

  for (var message of data.messages) {
    var updated;
    while (currentUpdate) {
      updated = currentUpdate.updated;
      if (Date.parse(updated) <= Date.parse(message.date)) {
        if (currentUpdate.state == "REVIEWER") {
          reviewers = reviewers.slice();
          reviewers.push(currentUpdate.reviewer.email);
          needsSyntheticMessage = true;
        }
        currentUpdate = reviewerUpdates[0];
        reviewerUpdates = reviewerUpdates.slice(1);
      } else {
        break;
      }
    }
    if (needsSyntheticMessage) {
      needsSyntheticMessage = false;
      if (mergedMessages.length == 0)
        var previousTimestamp = updated;
      else
        var previousTimestamp = mergedMessages[mergedMessages.length - 1].date;
      mergedMessages.push({
          date: updated,
          delta: Date.parse(updated) - Date.parse(previousTimestamp),
          reviewers,
          type: ChangedReviewers
        });
      message.delta -= mergedMessages[mergedMessages.length - 1].delta;
    }

    message.reviewers = reviewers;

    if (message.approval && !lgtm.includes(message.sender)) {
      lgtm = lgtm.slice();
      lgtm.push(message.sender);
      if (!reviewers.includes(message.sender)) {
        reviewers = reviewers.slice();
        reviewers.push(message.sender);
        message.reviewers = reviewers;
      }
    }
    message.lgtm = lgtm;

    message.all_lgtm = true;
    for (var reviewer of message.reviewers) {
      if (!lgtm.includes(reviewer))
        message.all_lgtm = false;
    }
    mergedMessages.push(message);
  }

  var newReviewers = reviewerUpdates.filter(update => update.state == "REVIEWER");
  if (newReviewers.length > 0) {
    reviewers = reviewers.concat(newReviewers.map(update => update.reviewer.email));
    var updated = newReviewers[0].updated;

    if (mergedMessages.length == 0)
      var previousTimestamp = updated;
    else
      var previousTimestamp = mergedMessages[mergedMessages.length - 1].date;
    mergedMessages.push({
      date: updated,
      delta: Date.parse(updated) - Date.parse(previousTimestamp),
      reviewers,
      type: ChangedReviewers
    });
    message.delta -= mergedMessages[mergedMessages.length - 1].delta;
  }

  data.messages = mergedMessages;
}

function classifyWaitingType(data) {
  // classify messages
  for (var i = 0; i < data.messages.length; i++) {
    var message = data.messages[i];

    if (message.reviewers.length == 0) {
      message.waitClass = Other;
      continue;
    }

    if (message.type == ChangedReviewers) {
      message.waitClass = WaitingForReview;
      continue;
    }

    if (!message.auto_generated && message.reviewers.includes(message.author.email)) {
      message.waitClass = WaitingForAuthor;
      continue;
    }

    if (message.type == CQBitChecked) {
      if (message.all_lgtm)
        message.waitClass = WaitingForBots;
      else if (i > 0)
        message.waitClass = data.messages[i - 1].waitClass;
      else
        message.waitClass = Other;
      continue;
    }

    if (message.type == CQBitUnchecked && message.all_lgtm) {
      message.waitClass = WaitingForAuthor;
      continue;
    }

    /*
     * The patch owner sent this message.
     *
     * Look through subsequent messages that
     * are sent by the sender or are autogenerated.
     * If any of them are responses to review comments
     * then the sender isn't waiting.
     */

    // check returns true if the sender is still reviewing in the future.
    function check(idx) {
      if (idx >= data.messages.length) {
        return false;
      }
      var message = data.messages[idx];
      if (!((message.sender == data.owner_email) || message.auto_generated))
        return false;
      if (message.type == ResponseToComments) {
        i = idx - 1;
        return true;
      }
      var isReviewingInFuture = check(idx + 1);
      if (isReviewingInFuture)
        message.waitClass = WaitingForAuthor;
      return isReviewingInFuture;
    }

    if (message.sender == data.owner_email && !message.auto_generated) {
      if (check(i + 1))
        message.waitClass = WaitingForAuthor;
      else if (message.all_lgtm)
        message.waitClass = WaitingForAuthor;
      else
        message.waitClass = WaitingForReview;
      continue;
    }

    if (message.type == Committed) {
      message.waitClass = NotWaiting;
      var j = i - 1;
      while (j >= 0) {
        data.messages[j].waitClass = WaitingForBots;
        if (data.messages[j--].type == CQBitChecked)
          break;
      }
      continue;
    }

    if (i == 0)
      message.waitClass = Other;
    else
      message.waitClass = data.messages[i - 1].waitClass;

  }
}

function analyzeSentiment(data) {
  if (!window.analysisToken) {
    return Promise.resolve();
  }
  let promises = [];
  for (let message of data.messages) {
    if (!message.comments)
      continue;
    var request = {
      document:{
        type: 'PLAIN_TEXT',
        content: message.comments.join('\n'),
      },
      encodingType: 'UTF8',
    };
    promises.push(fetch('https://language.googleapis.com/v1beta1/documents:analyzeSentiment', {
      method: 'POST',
      body: JSON.stringify(request),
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${analysisToken}`,
      },
    }).then(response => response.json()).then(json => message.analysis = json));
  }
  return Promise.all(promises);
}

function computeAggregateWaitingTimes(data) {
  var type = Other;
  data.waitingTimes = {};
  data.pendingWaiting = {};
  if (data.messages.length == 0)
    return;
  for (var message of data.messages) {
    if (data.waitingTimes[type] == undefined)
      data.waitingTimes[type] = 0;
    data.waitingTimes[type] += message.delta;
    type = message.waitClass;
  }

  var now = Date.now() + (new Date()).getTimezoneOffset() * 60 * 1000;
  var finalDelta = now - Date.parse(message.date);

  if (type != NotWaiting)
    data.waitingTimes[type] = (data.waitingTimes[type] || 0) + finalDelta;

  var alloc = (message.reviewers.length == 1 ? "sole" : "shared");
  data.reviewers = message.reviewers;

  if (type == WaitingForReview) {
    let reviewers = new Set(message.reviewers);
    for (var i = data.messages.length - 1; i >= 1 && data.messages[i].type == WaitingForReview; i--) {
      let message = data.messages[i];
      let previousMessage = data.messages[i - 1];
      if (previousMessage.type != WaitingForReview)
        break;
      for (let reviewer of reviewers.entries()) {
        if (previousMessage.reviewers.includes(reviewer)) {
          if (data.pendingWaiting[reviewer] == undefined)
            data.pendingWaiting[reviewer] = { sole: 0, shared: 0};
          data.pendingWaiting[reviewer][alloc] += message.delta;
        } else {
          reviewers.delete(reviewer);
        }
      }
    }
    message.reviewers.forEach(reviewer => {
      if (data.pendingWaiting[reviewer] == undefined) {
        data.pendingWaiting[reviewer] = { sole: 0, shared: 0};
      }
      data.pendingWaiting[reviewer][alloc] += finalDelta;
    });
  } else if (type == WaitingForAuthor) {
    if (data.pendingWaiting[data.owner.email] == undefined) {
      data.pendingWaiting[data.owner.email] = { sole: 0, shared: 0};
    }
    data.pendingWaiting[data.owner.email][alloc] += finalDelta;

    for (let i = data.messages.length - 1; i >= 1 && data.messages[i].type == WaitingForAuthor; i--) {
      let message = data.messages[i];
      let previousMessage = data.messages[i];
      if (previousMessage.type !== WaitingForAuthor)
        break;

      data.pendingWaiting[data.owner.email][alloc] += message.delta;
    }
  }
}

function addCodereviewStyleInfo(data) {
  data.owner = data.owner.email;
  data.issue = data._number;
}

return fastAnnotate;

})();
